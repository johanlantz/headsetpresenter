// Main program for UsbSnoop driver
// Generated by Walt Oney's driver wizard


#include "stddcls.h"
#include "driver.h"
#include "MyKdPrint.h"
#include "buffer.h"

NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo);
VOID DriverUnload(IN PDRIVER_OBJECT fido);
NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchPower(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchPnp(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS DispatchWmi(IN PDEVICE_OBJECT fido, IN PIRP Irp);
NTSTATUS MyDispatchInternalIOCTL(IN PDEVICE_OBJECT fido, IN PIRP Irp);
void DumpURB(struct Buffer *b, PURB pUrb, BOOLEAN bReturnedFromHCD);

BOOLEAN        isWin98 = FALSE;
UNICODE_STRING servkey;
BOOLEAN printNextURB = FALSE;  //j

//KMUTEX gMutex;
//KSEMAPHORE gSemaphore;
//KSPIN_LOCK gSpinLock;
//LIST_ENTRY gListHead;

KDPC gDPC;

// functions to handle conversion from PipeHandle to endpint number

struct ENDPOINT_INFO 
{
    USBD_PIPE_HANDLE PipeHandle;
	unsigned char    Endpoint;
};

// the number of endpoint that can be handled is defined here.
// if you use a device with more endpoints, they won't be decoded,
// but packets will be logged anyway.

struct ENDPOINT_INFO TabEndpointInfo[MAX_ENDPOINT] =
{
	{ NULL, 0 }
};

BOOLEAN GetEndpointInfo(USBD_PIPE_HANDLE inPipeHandle, unsigned char * outEndpoint)
{
	int i;

	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle != NULL 
			&& TabEndpointInfo[i].PipeHandle == inPipeHandle)
		{
			*outEndpoint = TabEndpointInfo[i].Endpoint;
			return TRUE;
		}
	}

	return FALSE;
}

void AddEndpointInfo(USBD_PIPE_HANDLE inPipeHandle, unsigned char inEndpoint)
{
	int i;

	// search for an existing PipeHandle
	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle != NULL 
			&& TabEndpointInfo[i].PipeHandle == inPipeHandle)
		{
			// if found, replace the Endpoint information
			TabEndpointInfo[i].Endpoint = inEndpoint;
			return ; 
		}
	}

	// search for a free slot 
	for (i=0;i<arraysize(TabEndpointInfo);i++)
	{
		if (TabEndpointInfo[i].PipeHandle == NULL)
		{
			TabEndpointInfo[i].PipeHandle = inPipeHandle;
			TabEndpointInfo[i].Endpoint = inEndpoint;
			return ;
		}
	}

	//logprintf("AddEndpointInfo failed!\n");
}



///////////////////////////////////////////////////////////////////////////////

void DumpStackLocation(PIO_STACK_LOCATION stack)
{
	if (stack == NULL)
		return ;

	//logprintf("    MajorFunction=%d, MinorFunction=%d\n",stack->MajorFunction,stack->MinorFunction);
	//logprintf("    DeviceObject=%p\n",stack->DeviceObject);
	//logprintf("    CompletionRoutine=%p Context=%p\n",stack->CompletionRoutine,stack->Context);

}

void DumpIrp(PIRP Irp)
{
	CHAR i;

	//logprintf("Dumping IRP %p\n",Irp);
	if (Irp==NULL)
		return ;

	//logprintf("  Type=%d, Size=%d\n",Irp->Type,Irp->Size);
	//LogPrintf("  StackCount=%d, CurrentLocation=%d\n",Irp->StackCount,Irp->CurrentLocation);
	for (i=0;i<Irp->StackCount;i++)
	{
		PIO_STACK_LOCATION stack = (PIO_STACK_LOCATION) (Irp+1) + i;
		//LogPrintf("  [%d] MajorFunction=%d, MinorFunction=%d, DeviceObject=%p\n",i,stack->MajorFunction,stack->MinorFunction,stack->DeviceObject);
		//LogPrintf("      Arg1=%p, Arg2=%p, Arg3=%p, Arg4=%p\n",stack->Parameters.Others.Argument1,stack->Parameters.Others.Argument2,stack->Parameters.Others.Argument3,stack->Parameters.Others.Argument4);
		//LogPrintf("      CompletionRoutine=%p Context=%p\n",stack->CompletionRoutine,stack->Context);
	}
}

void DumpDriverObject(PDRIVER_OBJECT p)
{
//	int i;

	//logprintf("UsbSnoop - DumpDriverObject : p = %p\n",p);
	//logprintf("  Type = %d\n",p->Type);
	//logprintf("  Size = %d\n",p->Size);
	//logprintf("  DeviceObject = %p\n",p->DeviceObject);
	//logprintf("  Flags = 0x%x\n",p->Flags);
	//logprintf("  DriverStart = %p\n",p->DriverStart);
	//logprintf("  DriverSize = %d\n",p->DriverSize);
	//logprintf("  DriverSection = %p\n",p->DriverSection);
	//logprintf("  DriverExtension = %p\n",p->DriverExtension);
	//logprintf("  DriverExtension->AddDevice = %p\n",p->DriverExtension->AddDevice);
	//logprintf("  FastIoDispatch = %p\n",p->FastIoDispatch);
	//logprintf("  DriverInit = %p\n",p->DriverInit);
	//logprintf("  DriverStartIo = %p\n",p->DriverStartIo);
	//logprintf("  DriverUnload = %p\n",p->DriverUnload);
	//for (i=0;i<IRP_MJ_MAXIMUM_FUNCTION + 1;i++)
	//	LogPrintf("  MajorFunction[%d] = %p\n",i,p->MajorFunction[i]);
}

void DumpDeviceObject(PDEVICE_OBJECT p)
{
	PDEVICE_EXTENSION pdx;

	//logprintf("UsbSnoop - DumpDeviceObject : p = %p\n",p);
	//logprintf("  DriverObject = %p\n",p->DriverObject);
	//logprintf("  NextDevice = %p\n",p->NextDevice);
	//logprintf("  AttachedDevice = %p\n",p->AttachedDevice);
	//logprintf("  StackSize=%d\n",p->StackSize);
	//logprintf("  CurrentIrp = %p\n",p->CurrentIrp);
	//logprintf("  DeviceObjectExtension = %p\n",p->DeviceObjectExtension);

	pdx = (PDEVICE_EXTENSION)p->DeviceObjectExtension;

	//logprintf("   ->DeviceObject=%p\n",pdx->DeviceObject);
	//logprintf("   ->LowerDeviceObject=%p\n",pdx->LowerDeviceObject);
	//logprintf("   ->Pdo=%p\n",pdx->Pdo);
}

void DumpContext(PCONTEXT Context)
{
	//logprintf("DumpContext : Context=%p\n",Context);
	//logprintf("  CompletionRoutine=%p, Context=%p, Control=%x\n",Context->CompletionRoutine,Context->Context,Context->Control);
	//LogPrintf("  pUrb=%p, uSequenceNumber=%d, Stack=%p\n",Context->pUrb,Context->uSequenceNumber,Context->Stack);
}

void Sleep(int nsecond)
{
	LARGE_INTEGER li;

	li.QuadPart = - nsecond * SECONDS;

	KeDelayExecutionThread(KernelMode,FALSE,&li);
}

/*
void ThreadStart(PVOID myThreadId)
{
	NTSTATUS status;
	LARGE_INTEGER li;
	int threadID = * (int *) myThreadId;

	// we start at IRQL PASSIVE_LEVEL (0)

	LogPrintf("Thread[%d] : KeGetCurrentIrql=%d\n",
		threadID,KeGetCurrentIrql()));

	int i;

	for (i=0;i<0;i++)
	{
		LogPrintf("Thread[%d] : Je VEUX le mutex! IRQL=%d\n",threadID,
			KeGetCurrentIrql()));
		KeWaitForMutexObject(&gMutex,Executive,KernelMode,FALSE,NULL);
		LogPrintf("Thread[%d] : J'ai le mutex!!! IRQL=%d\n",threadID,
			KeGetCurrentIrql()));

		// with "slow" mutex, we are still at IRQL PASSIVE_LEVEL
		// with "fast" mutex, we are now at IRQL APC_LEVEL

		IO_STATUS_BLOCK ioStatusBlock;
		const char str1[] = "from inside the mutex\n";

		status = ZwWriteFile(fileHandle,NULL,NULL,NULL,&ioStatusBlock,
			(PVOID)str1,strlen(str1),NULL,NULL);
		if (status != STATUS_SUCCESS)
			LogPrintf("ZwWriteFile1 failed : status = 0x%x\n",status));


		li.QuadPart = - 1 * SECONDS;

		status = KeDelayExecutionThread(KernelMode,FALSE,&li);
		LogPrintf("KeDelayExecutionThread = %d\n",status));

		LogPrintf("Thread[%d] : C'est bon, je relache le mutex :-(\n",
			threadID));
		KeReleaseMutex(&gMutex,FALSE);
	}

	// try to remove an entry from the list

	PLIST_ENTRY pEntry;

	do {
		status = KeWaitForSingleObject(&gSemaphore,Executive,KernelMode,FALSE,NULL);
		if (status != STATUS_SUCCESS)
		{
			LogPrintf("KeWaitForSingleObject = %d\n",status));
			break;
		}

		pEntry = ExInterlockedRemoveHeadList(&gListHead,&gSpinLock);
	} while (pEntry == NULL);

	LogPrintf("Thread[%d] : pEntry=%p\n",threadID,pEntry));

	LogPrintf("Thread[%d] : Je joue plus\n",threadID));
	status = PsTerminateSystemThread(0);

	// next line is never displayed. This should mean that the thread
	// has already terminated sucessfully! :-)
	LogPrintf("PsTerminateSystemThread=%d\n",status));
}
*/

#pragma INITCODE

/*
	DriverEntry : this function is called by Windows whenever this driver is
		loaded in memory, this is the only entry point this is accessible for
		the OS. Other entry points will be set up inside DriverEntry().

	From the Windows 2000 DDK : DriverEntry routines are called in the context
	of a system thread at IRQL PASSIVE_LEVEL.
*/

extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,
								IN PUNICODE_STRING RegistryPath)
{
	UCHAR MajorVersion, MinorVersion;
	int i;
	//char msg[] = "UsbSnoop compiled on " __DATE__ " " __TIME__ " loading\n";

	LogInit();


	//DbgPrint(msg);
	//LogPrintf(msg);

	// Insist that OS support at least the WDM 1.0 (Win98 DDK)
	
	if (!IoIsWdmVersionAvailable(1, 0))
	{
//		LogPrintf("UsbSnoop - Expected version of WDM (%d.%d) not available\n", 1, 0);
		return STATUS_UNSUCCESSFUL;
	}
	
	// See if we're running under Win98 or NT:
	
	isWin98 = !IoIsWdmVersionAvailable(1, 10); //DriverObject->DriverExtension->ServiceKeyName.Length == 0;
	
	MajorVersion = 0;
	MinorVersion = 0;

	while (IoIsWdmVersionAvailable(MajorVersion,MinorVersion))
		MajorVersion ++;

	MajorVersion --;

	while (IoIsWdmVersionAvailable(MajorVersion,MinorVersion))
		MinorVersion ++;
	MinorVersion --;

	//if (isWin98)
		//LogPrintf("UsbSnoop - DriverEntry(%p) : Windows 98 WDM version %d.%d\n",DriverEntry,MajorVersion,MinorVersion);
	//else
		// version 1.16 used under Windows 2000
		//LogPrintf("UsbSnoop - DriverEntry(%p) : Windows NT WDM version %d.%d\n",DriverEntry,MajorVersion,MinorVersion);

//	DumpDriverObject(DriverObject);

	// Save the name of the service key

	servkey.Buffer = (PWSTR) ExAllocatePool(NonPagedPool, RegistryPath->MaximumLength);
	if (servkey.Buffer == NULL)
	{
		//LogPrintf("UsbSnoop - Unable to allocate %d bytes for copy of service key name\n", RegistryPath->MaximumLength);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	servkey.MaximumLength = RegistryPath->MaximumLength;
	RtlCopyUnicodeString(&servkey, RegistryPath);

	// Initialize function pointers

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->DriverExtension->AddDevice = AddDevice;
	
	for (i = 0; i < arraysize(DriverObject->MajorFunction); ++i)
		DriverObject->MajorFunction[i] = DispatchAny;

	// POWER IRP needs a special treatment
	DriverObject->MajorFunction[IRP_MJ_POWER] = DispatchPower;

	// we need a special callback to call RemoveDevice().
	// this is now done in MyDispatchPnp
	// DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;

	return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

/*
	DriverUnload() is called whenever our driver is unloaded from memory.
	From Windows 2000 DDK : run at PASSIVE_LEVEL, as are any driver-created
	system threads. 
*/

VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
	char msg [] = "Driver unloaded!\n";

	//LogPrintf("UsbSnoop - DriverUnload(%p) : DriverObject %p, IRQL=%d\n",DriverUnload,DriverObject,KeGetCurrentIrql());

//	DumpDriverObject(DriverObject);
	RtlFreeUnicodeString(&servkey);

	//logprintf(msg);
	LogDone();

	/*
		let the time for the thread to stop. It's no longer needed, since we
		use an event to synchronize the destruction of the thread.
		after that, we CANNOT call LogPrintf).
	*/

	DbgPrint(msg);
}

const char * GetIrpPnpMinorFunctionName(ULONG fcn)
{
	static const char* fcnname[] =
	{
		"IRP_MN_START_DEVICE",
		"IRP_MN_QUERY_REMOVE_DEVICE",
		"IRP_MN_REMOVE_DEVICE",
		"IRP_MN_CANCEL_REMOVE_DEVICE",
		"IRP_MN_STOP_DEVICE",
		"IRP_MN_QUERY_STOP_DEVICE",
		"IRP_MN_CANCEL_STOP_DEVICE",
		"IRP_MN_QUERY_DEVICE_RELATIONS",
		"IRP_MN_QUERY_INTERFACE",
		"IRP_MN_QUERY_CAPABILITIES",
		"IRP_MN_QUERY_RESOURCES",
		"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
		"IRP_MN_QUERY_DEVICE_TEXT",
		"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
		"",
		"IRP_MN_READ_CONFIG",
		"IRP_MN_WRITE_CONFIG",
		"IRP_MN_EJECT",
		"IRP_MN_SET_LOCK",
		"IRP_MN_QUERY_ID",
		"IRP_MN_QUERY_PNP_DEVICE_STATE",
		"IRP_MN_QUERY_BUS_INFORMATION",
		"IRP_MN_DEVICE_USAGE_NOTIFICATION",
		"IRP_MN_SURPRISE_REMOVAL",
	};

	if (0<=fcn && fcn<arraysize(fcnname))
		return fcnname[fcn];

	return NULL;
}

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

VOID RemoveDevice(IN PDEVICE_OBJECT fido)
{
//	PAGED_CODE();

	// since we called this function before the original one,
	// we are sure that the lower device object is still the same

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;

	//logprintf("UsbSnoop - RemoveDevice(%p) : fido=%p pdx=%p\n",RemoveDevice,fido,pdx);
	
	if (pdx->LowerDeviceObject != NULL)
	{
		// save our modified PDRIVER_OBJECT
		PDRIVER_OBJECT d = pdx->LowerDeviceObject->DriverObject;

//		LogPrintf("  fdo=%p OriginalDriverObject=%p d=%p\n",
//			pdx->LowerDeviceObject,pdx->OriginalDriverObject,d);

		// restore the driver pointer in the PDO
		pdx->LowerDeviceObject->DriverObject = pdx->OriginalDriverObject;

		IoDetachDevice(pdx->LowerDeviceObject);

		// free our modified PDRIVER_OBJECT
		ExFreePool(d);
	}

	IoDeleteDevice(fido);
}

NTSTATUS MyDispatchPnp(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	PDEVICE_OBJECT fido;
//	NTSTATUS status;
	PDEVICE_EXTENSION pdx;
	
	const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
	//if (MinorFunctionName != NULL)
		//LogPrintf("UsbSnoop - MyDispatchPNP(%p) : IRP_MJ_PNP (%s)\n",MyDispatchPnp,MinorFunctionName);
	//else
		//LogPrintf("UsbSnoop - MyDispatchPNP(%p) : IRP_MJ_PNP (0x%x)\n",MyDispatchPnp,fcn);

	
	fido = fdo->AttachedDevice;
//	LogPrintf("fido=%p\n",fido);

	pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
//	LogPrintf("pdx=%p\n",pdx);

	// save the original function to call

	PDRIVER_DISPATCH pfn = pdx->OriginalDriverObject->MajorFunction[IRP_MJ_PNP];

	// the following lines should be executed ONLY if DispatchPNP() callback
	// is not used, since it duplicates its work.

	// They should also be executed BEFORE calling the original Dispatch function
	// since this original Dispatch function will surely destroy its DeviceObject.

	if (fcn == IRP_MN_REMOVE_DEVICE)
		RemoveDevice(fido);
	
	return pfn(fdo,Irp);	
}

/*
	Experimentally, under Windows 2000, run at IRQL DISPATCH_LEVEL,
	which is not enought for us, since ZwWriteFile() must be called
	at IRQL PASSIVE_LEVEL
*/

VOID gDeferredRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{

	KIRQL currentIrql = KeGetCurrentIrql();
	DbgPrint("gDeferredRoutine : currentIrql=%d\n",currentIrql);
}

/*
	AddDevice is called by Windows for each device we have to managed. This is
	where we get the oportunity to be added in the device object stack.

  From the Windows 2000 DDK : An AddDevice routine is called in the context of
  a system thread at IRQL PASSIVE_LEVEL.

  A device driver can register a CustomDpc routine by calling KeInitializeDpc
  after creating a device object. The driver should make this call from its
  AddDevice routine. Callers of this routine must be running at
  IRQL PASSIVE_LEVEL.
*/

NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo)
{
	NTSTATUS status;
	PDEVICE_OBJECT fido, fdo;
	PDEVICE_EXTENSION pdx;
	PDRIVER_OBJECT d;

//	PAGED_CODE();

	//LogPrintf("UsbSnoop - AddDevice(%p) : DriverObject %p, pdo %p\n",AddDevice,DriverObject, pdo);

//	DumpDriverObject(DriverObject);
//	DumpDeviceObject(pdo);

	// create a custom DPC
	//KeInitializeDpc(&gDPC,gDeferredRoutine,NULL);

	// Create a UsbSnoop device object to represent the hardware we're managing.
	
	status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),NULL,
		FILE_DEVICE_UNKNOWN, 0, FALSE, &fido);
	if (!NT_SUCCESS(status))
	{						// can't create device object
		//logprintf("UsbSnoop - IoCreateDevice failed - %x\n", status);
		return status;
	}						// can't create device object

	// Benoit PAPILLAULT 13/07/2001
	// fido->DeviceExtension is a user define structure whose size is passed
	// to IoCreateDevice(). We can store whatever we want inside.

	pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
//	LogPrintf("  fido=%p pdx=%p\n",fido,pdx);
	
	// From this point forward, any error will have side effects that need to
	// be cleaned up. Using a try-finally block allows us to modify the program
	// easily without losing track of the side effects.
	
	__try
	{						// finish initialization
		IoInitializeRemoveLock(&pdx->RemoveLock, 0, 0, 255);
		pdx->DeviceObject = fido;
		pdx->Pdo = pdo;
		
		// Add our device object to the stack and propagate critical settings
		// from the immediately lower device object
		
		fdo = IoAttachDeviceToDeviceStack(fido, pdo);

		pdx->LowerDeviceObject = fdo;
		fido->Flags |= fdo->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE | DO_POWER_INRUSH);
		fido->DeviceType = fdo->DeviceType;
		fido->Characteristics = fdo->Characteristics;
		fido->AlignmentRequirement = fdo->AlignmentRequirement;
		
		// Clear the "initializing" flag so that we can get IRPs
		
		fido->Flags &= ~DO_DEVICE_INITIALIZING;

//		DumpDriverObject(DriverObject);
//		DumpDeviceObject(fdo);
//		DumpDeviceObject(fido);
//		DumpDeviceObject(pdo);

		// we make a copy of fdo->DriverObject
		d = (PDRIVER_OBJECT)ExAllocatePool(NonPagedPool,sizeof(DRIVER_OBJECT));
		if (d != NULL)
		{
			*d = *fdo->DriverObject;

			// we make some changes to this copy
			d->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = MyDispatchInternalIOCTL;
			d->MajorFunction[IRP_MJ_PNP]                     = MyDispatchPnp;

			// here is the trick : we save the original DriverObject
			// and next, it points to our modified copy
			pdx->OriginalDriverObject = fdo->DriverObject;
			fdo->DriverObject = d;

//			LogPrintf("  fdo=%p OriginalDriverObject=%p d=%p\n",
//				fdo,pdx->OriginalDriverObject,d);
		}
		//else
			//logprintf("ExAllocatePool failed : not redirecting PDO->DriverObject\n");
	}						// finish initialization
	__finally
	{						// cleanup side effects
		if (!NT_SUCCESS(status))
		{					// need to cleanup
			IoDeleteDevice(fido);
		}					// need to cleanup
	}						// cleanup side effects
	
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE

NTSTATUS CompleteRequest(IN PIRP Irp, IN NTSTATUS status, IN ULONG info)
{
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = info;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

#pragma LOCKEDCODE				// make no assumptions about pageability of dispatch fcns

NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	NTSTATUS status;
	
	const char* irpname[] =
	{
		"IRP_MJ_CREATE",
		"IRP_MJ_CREATE_NAMED_PIPE",
		"IRP_MJ_CLOSE",
		"IRP_MJ_READ",
		"IRP_MJ_WRITE",
		"IRP_MJ_QUERY_INFORMATION",
		"IRP_MJ_SET_INFORMATION",
		"IRP_MJ_QUERY_EA",
		"IRP_MJ_SET_EA",
		"IRP_MJ_FLUSH_BUFFERS",
		"IRP_MJ_QUERY_VOLUME_INFORMATION",
		"IRP_MJ_SET_VOLUME_INFORMATION",
		"IRP_MJ_DIRECTORY_CONTROL",
		"IRP_MJ_FILE_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CONTROL",
		"IRP_MJ_INTERNAL_DEVICE_CONTROL",
		"IRP_MJ_SHUTDOWN",
		"IRP_MJ_LOCK_CONTROL",
		"IRP_MJ_CLEANUP",
		"IRP_MJ_CREATE_MAILSLOT",
		"IRP_MJ_QUERY_SECURITY",
		"IRP_MJ_SET_SECURITY",
		"IRP_MJ_POWER",
		"IRP_MJ_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CHANGE",
		"IRP_MJ_QUERY_QUOTA",
		"IRP_MJ_SET_QUOTA",
		"IRP_MJ_PNP",
	};
	
	UCHAR type = stack->MajorFunction;

	if (type == IRP_MJ_PNP)
	{
		ULONG fcn = stack->MinorFunction;
	
		const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
		//if (MinorFunctionName != NULL)
			//LogPrintf("UsbSnoop - DispatchAny(%p) : IRP_MJ_PNP (%s)\n",DispatchAny,MinorFunctionName);
	//	else
			//LogPrintf("UsbSnoop - DispatchAny(%p) : IRP_MJ_PNP (0x%x)\n",DispatchAny,fcn);
	}
	else
	{
		//if (type >= arraysize(irpname))
			//LogPrintf("UsbSnoop - DispatchAny(%p) : Unknown IRP, MajorFunction=0x%x\n",DispatchAny,type);
		//else
			//LogPrintf("UsbSnoop - DispatchAny(%p) : %s\n",DispatchAny, irpname[type]);
	}
	
	// Pass request down without additional processing
	
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
//	LogPrintf("before IoCallDriver %p %p\n",pdx->LowerDeviceObject, Irp));
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
//	LogPrintf("after  IoCallDriver %p %p\n",pdx->LowerDeviceObject, Irp));
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

void DumpBuffer(struct Buffer *b, unsigned char * buf, int len)
{
#define NB_BYTE 24 /* number of bytes displayed per line */ //j changed here. Was 16

	char str[NB_BYTE*3 + 1];
	int i,j;

	for (i=0;i<len;i+=NB_BYTE)
	{
		char * p = str;

		for (j=i;j<len&&j<i+NB_BYTE;j++)
		{
			char c;

			*p++ = ' ';			//mellanslaget i utskriften
			c = (buf[j] >> 4) & 0xf;
			*p++ = (c<10) ? c+'0' : c-10+'a';
			c = buf[j] & 0xf;
			*p++ = (c<10) ? c+'0' : c-10+'a';
		}
		*p = 0;
	
		/*This addon will check for AT+CKPD and AT+VGS.
		  If they are present we will cut out 22 chars and send to the log.
		  This should be sufficient for AT+CKPD=2 as well as AT+VGS=15 both nine chars => need buffer size 9*2+8 = 26*/
		//BufferPrintf(b,"    %x:%s\n",i,str);  //j remove this later
		
		char* pos;
		//char strToPrint[27];  //size of AT command should be 26 + 1 for \0	
		//strToPrint[26] = '\0';//\0 is not automatically added if count in strncpy is less then the size of the source string

		//JJ for headsetpresenter 3.0, try checking for any AT command
		pos = strstr(str,"41 54 2b");
		if(pos != NULL)
		{
			//strncpy(strToPrint, pos, 26);
			//BufferPrintf(b,"    %x:%s\n",i,strToPrint);
			BufferPrintf(b,"    %x:%s\n",i,str);  //trying to print the full buffer
		}
		//Check for AT+CKPD 
		/*pos = strstr(str,"41 54 2b 43 4b 50 44 3d 32");
		if(pos != NULL)
		{
			//strncpy(strToPrint, pos, 26);
			//BufferPrintf(b,"    %x:%s\n",i,strToPrint);
			BufferPrintf(b,"    %x:%s\n",i,str);  //trying to print the full buffer
		}

		//Check for AT+VGS
		pos = strstr(str,"41 54 2b 56 47 53 3d");
		if(pos != NULL)
		{
			//strncpy(strToPrint, pos, 26);
			//BufferPrintf(b,"    %x:%s\n",i,strToPrint);
			BufferPrintf(b,"    %x:%s\n",i,str); //trying to print the full buffer
		}*/
		
		pos = strstr(str,"00 48 7c");
		if(pos != NULL)
		{
			//strncpy(strToPrint, pos, 26);
			//BufferPrintf(b,"    %x:%s\n",i,strToPrint);
			BufferPrintf(b,"    %x:%s\n",i,str); //trying to print the full buffer
		}
		/*New code here, check for Connection_Request*/
		/*pos = strstr(str,"04 0a");
		if(pos != NULL)
		{
			if(*(pos+33) == '0' && *(pos+34) == '1')
			{
				BufferPrintf(b,"    %x:%s\n",i,str); //found Connection_Request for ACL link
			}
		}*/
	}
}

/*
	Dump a buffer. Its address is either pBuffer or pMdl.
	It dumps for uBufferSize bytes starting at
	pBuffer (or pMDL) + uBufferOffset. This later is optionnal (currently)
*/

void DumpTransferBuffer(struct Buffer *b,
						PUCHAR pBuffer, PMDL pMdl, ULONG uBufferSize,
						BOOLEAN bPrintHeader,ULONG uBufferOffset = 0)
{
	if(bPrintHeader)
	{
		//BufferPrintf(b,"  TransferBufferLength = %x\n", uBufferSize);  
		//BufferPrintf(b,"  TransferBuffer       = %x\n", pBuffer);			//j
		//BufferPrintf(b,"  TransferBufferMDL    = %x\n", pMdl);			//j
	}
	else
	{
		if(pBuffer)
		{
			if(pMdl)
			{
				//LogPrintf("??? weird transfer buffer, both MDL and flat specified. Ignoring MDL\n"));
			}
			//the AT commands are pBuffers
			DumpBuffer(b,pBuffer+uBufferOffset,uBufferSize);
		}
		else if(pMdl)
		{
			PUCHAR pMDLBuf = (PUCHAR)MmGetSystemAddressForMdl(pMdl);
			if(pMDLBuf)
				DumpBuffer(b,pMDLBuf+uBufferOffset,uBufferSize);
			else
			{
				//BufferPrintf(b,"XXXXX ERROR: can't map MDL!\n");
			}
		}
		else
		{
			//BufferPrintf(b,"\n    no data supplied\n");
		}
	}
}

void DumpGetStatusRequest(struct Buffer *b,
						  struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusRequest,
						  BOOLEAN bReturnedFromHCD)
{
	DumpTransferBuffer(b,(PUCHAR)pGetStatusRequest->TransferBuffer, pGetStatusRequest->TransferBufferMDL, pGetStatusRequest->TransferBufferLength, TRUE);
	if(pGetStatusRequest->TransferBufferLength != 1)
		//BufferPrintf(b,"  *** error - TransferBufferLength should be 1!\n");
	if(bReturnedFromHCD)
	{
		DumpTransferBuffer(b,(PUCHAR)pGetStatusRequest->TransferBuffer, pGetStatusRequest->TransferBufferMDL, pGetStatusRequest->TransferBufferLength, FALSE);
	}

	//BufferPrintf(b,"  Index                = %x\n", pGetStatusRequest->Index);
	
	if(pGetStatusRequest->UrbLink)
	{
		//BufferPrintf(b,"---> Linked URB:\n");
		DumpURB(b,pGetStatusRequest->UrbLink, bReturnedFromHCD);
		//BufferPrintf(b,"---< Linked URB\n");
	}
}

void DumpFeatureRequest(struct Buffer *b,
						struct _URB_CONTROL_FEATURE_REQUEST *pFeatureRequest,
						BOOLEAN bReadFromDevice, BOOLEAN bReturnedFromHCD)
{
	//BufferPrintf(b,"  FeatureSelector = %x\n", pFeatureRequest->FeatureSelector);
	//BufferPrintf(b,"  Index           = %x\n", pFeatureRequest->Index);
	if(pFeatureRequest->UrbLink)
	{
		//BufferPrintf(b,"---> Linked URB:\n");
		DumpURB(b,pFeatureRequest->UrbLink, bReturnedFromHCD);
		//BufferPrintf(b,"---< Linked URB\n");
	}
}

void DumpDescriptorRequest(struct Buffer *b,
						   struct _URB_CONTROL_DESCRIPTOR_REQUEST *pDescriptorRequest,
						   BOOLEAN bReadFromDevice, BOOLEAN bReturnedFromHCD)
{
	DumpTransferBuffer(b,(PUCHAR)pDescriptorRequest->TransferBuffer, pDescriptorRequest->TransferBufferMDL, pDescriptorRequest->TransferBufferLength, TRUE);
	if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
	{
		DumpTransferBuffer(b,(PUCHAR)pDescriptorRequest->TransferBuffer, pDescriptorRequest->TransferBufferMDL, pDescriptorRequest->TransferBufferLength, FALSE);
	}

	//BufferPrintf(b,"  Index                = %x\n", pDescriptorRequest->Index);
	//BufferPrintf(b,"  DescriptorType       = %x (%s)\n", pDescriptorRequest->DescriptorType,
	//	pDescriptorRequest->DescriptorType == USB_DEVICE_DESCRIPTOR_TYPE ? "USB_DEVICE_DESCRIPTOR_TYPE" :
	//	pDescriptorRequest->DescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE ? "USB_CONFIGURATION_DESCRIPTOR_TYPE" :
	//	pDescriptorRequest->DescriptorType == USB_STRING_DESCRIPTOR_TYPE ? "USB_STRING_DESCRIPTOR_TYPE" : "<illegal descriptor type!>");
	//BufferPrintf(b,"  LanguageId           = %x\n", pDescriptorRequest->LanguageId);
	
	if(pDescriptorRequest->UrbLink)
	{
		//BufferPrintf(b,"---> Linked URB:\n");
		DumpURB(b,pDescriptorRequest->UrbLink, bReturnedFromHCD);
		//BufferPrintf(b,"---< Linked URB\n");
	}
}

void DumpVendorOrClassRequest(struct Buffer *b,
							  struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassInterface, BOOLEAN bReturnedFromHCD)
{
	BOOLEAN bReadFromDevice = (BOOLEAN)(pFunctionClassInterface->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
	//BufferPrintf(b,"  TransferFlags          = %x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pFunctionClassInterface->TransferFlags,
	//	bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
	//	pFunctionClassInterface->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~");

	DumpTransferBuffer(b,(PUCHAR)pFunctionClassInterface->TransferBuffer, pFunctionClassInterface->TransferBufferMDL, pFunctionClassInterface->TransferBufferLength, TRUE);
	if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
	{
		DumpTransferBuffer(b,(PUCHAR)pFunctionClassInterface->TransferBuffer, pFunctionClassInterface->TransferBufferMDL, pFunctionClassInterface->TransferBufferLength, FALSE);
	}

	//BufferPrintf(b,"  UrbLink                 = %x\n", pFunctionClassInterface->UrbLink);
	//BufferPrintf(b,"  RequestTypeReservedBits = %x\n", pFunctionClassInterface->RequestTypeReservedBits);
	//BufferPrintf(b,"  Request                 = %x\n", pFunctionClassInterface->Request);
	//BufferPrintf(b,"  Value                   = %x\n", pFunctionClassInterface->Value);
	//BufferPrintf(b,"  Index                   = %x\n", pFunctionClassInterface->Index);
	if(pFunctionClassInterface->UrbLink)
	{
		//BufferPrintf(b,"---> Linked URB:\n");
		DumpURB(b,pFunctionClassInterface->UrbLink, bReturnedFromHCD);
		//BufferPrintf(b,"---< Linked URB\n");
	}
}

void DumpPipeHandle(struct Buffer *b,const char *s,
					USBD_PIPE_HANDLE inPipeHandle)
{
	//unsigned char ep;

	// search for the matching endpoint

	//if (GetEndpointInfo(inPipeHandle,&ep))
		//BufferPrintf(b,"%s = %p [endpoint 0x%x]\n",s,inPipeHandle,ep);
	//else
		//BufferPrintf(b,"%s = %p\n",s,inPipeHandle);
}

void DumpURB(struct Buffer *b, PURB pUrb, BOOLEAN bReturnedFromHCD)
{
	USHORT wFunction, wLength;
	USBD_STATUS lUsbdStatus;

	if (pUrb == NULL)
	{
		//BufferPrintf(b,"UsbSnoop - URB == NULL ???\n");
		return;
	}

	if (pUrb->UrbHeader.Length < sizeof(pUrb->UrbHeader))
	{
		//BufferPrintf(b,"UsbSnoop - incorrect UrbHeader.Length=%d, should be at least %d\n",
		//	pUrb->UrbHeader.Length,sizeof(pUrb->UrbHeader));
		return ;
	}

	wFunction = pUrb->UrbHeader.Function;
	wLength = pUrb->UrbHeader.Length;
	lUsbdStatus = pUrb->UrbHeader.Status;

	/* Status values are defined in <usbdi.h> as USBD_STATUS_XXX */
//	LogPrintf("  Header.Length = %d\n",          pUrb->UrbHeader.Length));
//	LogPrintf("  Header.Function = 0x%x\n",      pUrb->UrbHeader.Function));
//	LogPrintf("  Header.Status = 0x%x\n",        pUrb->UrbHeader.Status));
//	LogPrintf("  Header.UsbdDeviceHandle = %p\n",pUrb->UrbHeader.UsbdDeviceHandle));
//	LogPrintf("  Header.UsbdFlags = 0x%x\n",     pUrb->UrbHeader.UsbdFlags));

	switch(wFunction)
	{
	case URB_FUNCTION_SELECT_CONFIGURATION:
		{

			/* _URB_SELECT_CONFIGURATION is as follows :

			- a first block of 16 bytes : struct _URB_HEADER Hdr
			- a pointer (4 bytes) : PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
			      this can be a NULL pointer, in which case the array of USBD_INTERFACE_INFORMATION
				  is empty.
			- a handle (4 bytes) : USBD_CONFIGURATION_HANDLE ConfigurationHandle
			- an array of USBD_INTERFACE_INFORMATION, whose number are
			    ConfigurationDescriptor.bNumInterfaces

			each USBD_INTERFACE_INFORMATION contains fixed information (16 bytes), followed
			  by an array of USB_PIPE_INFORMATION (20 bytes) whose number is NumberOfPipes.
			*/

#define URB_SELECT_CONFIGURATION_SIZE 24

			struct _URB_SELECT_CONFIGURATION *pSelectConfiguration = (struct _URB_SELECT_CONFIGURATION*) pUrb;
			//BufferPrintf(b,"-- URB_FUNCTION_SELECT_CONFIGURATION:\n");
			if(pSelectConfiguration->Hdr.Length < URB_SELECT_CONFIGURATION_SIZE)
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pSelectConfiguration->Hdr.Length,URB_SELECT_CONFIGURATION_SIZE);
				return ;
			}

			PUSB_CONFIGURATION_DESCRIPTOR pCD = pSelectConfiguration->ConfigurationDescriptor;
			//BufferPrintf(b,"  ConfigurationDescriptor = 0x%x %s\n",pCD,pCD ? "(configure)":"(unconfigure)");
			if (pCD == NULL)
				break;

			//BufferPrintf(b,"  ConfigurationDescriptor : bLength             = %d\n", pCD->bLength);
			//BufferPrintf(b,"  ConfigurationDescriptor : bDescriptorType     = 0x%x\n", pCD->bDescriptorType);
			//BufferPrintf(b,"  ConfigurationDescriptor : wTotalLength        = 0x%x\n", pCD->wTotalLength);
			//BufferPrintf(b,"  ConfigurationDescriptor : bNumInterfaces      = 0x%x\n", pCD->bNumInterfaces);
			//BufferPrintf(b,"  ConfigurationDescriptor : bConfigurationValue = 0x%x\n", pCD->bConfigurationValue);
			//BufferPrintf(b,"  ConfigurationDescriptor : iConfiguration      = 0x%x\n", pCD->iConfiguration);
			//BufferPrintf(b,"  ConfigurationDescriptor : bmAttributes        = 0x%x\n", pCD->bmAttributes);
			//BufferPrintf(b,"  ConfigurationDescriptor : MaxPower            = 0x%x\n", pCD->MaxPower);
			//BufferPrintf(b,"  ConfigurationHandle     = 0x%x\n", pSelectConfiguration->ConfigurationHandle);
			
			ULONG uNumInterfaces = pCD->bNumInterfaces;

			if(uNumInterfaces > 0xff)
			{
				//BufferPrintf(b,"XXXXXX ERROR: uNumInterfaces is too large (%d), resetting to 1\n", uNumInterfaces);
				uNumInterfaces = 1;
			}
			
			
			PUSBD_INTERFACE_INFORMATION pInterface = &pSelectConfiguration->Interface;
			for(ULONG i = 0; i < uNumInterfaces; i++)
			{
				//BufferPrintf(b,"  Interface[%d]: Length            = %d\n", i, pInterface->Length);
				//BufferPrintf(b,"  Interface[%d]: InterfaceNumber   = %d\n", i, pInterface->InterfaceNumber);
				//BufferPrintf(b,"  Interface[%d]: AlternateSetting  = %d\n", i, pInterface->AlternateSetting);
				if(bReturnedFromHCD)
				{
					ULONG uNumPipes;
					//BufferPrintf(b,"  Interface[%d]: Class             = 0x%x\n", i, pInterface->Class);
					//BufferPrintf(b,"  Interface[%d]: SubClass          = 0x%x\n", i, pInterface->SubClass);
					//BufferPrintf(b,"  Interface[%d]: Protocol          = 0x%x\n", i, pInterface->Protocol);
					//BufferPrintf(b,"  Interface[%d]: InterfaceHandle   = 0x%x\n", i, pInterface->InterfaceHandle);
					//BufferPrintf(b,"  Interface[%d]: NumberOfPipes     = %d\n", i, pInterface->NumberOfPipes);
					
					uNumPipes = pInterface->NumberOfPipes;
					if(uNumPipes > 0x1f)
					{
						//BufferPrintf(b,"XXXXXX ERROR: uNumPipes is too large (%d), resetting to 1\n", uNumPipes);
						uNumPipes = 1;
					}
					for(ULONG p = 0; p< uNumPipes; p++)
					{
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : MaximumPacketSize = 0x%x\n", i, p, pInterface->Pipes[p].MaximumPacketSize);
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : EndpointAddress   = 0x%x\n", i, p, pInterface->Pipes[p].EndpointAddress);
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : Interval          = 0x%x\n", i, p, pInterface->Pipes[p].Interval);
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : PipeType          = 0x%x (%s)\n", i, p, pInterface->Pipes[p].PipeType,
						//	pInterface->Pipes[p].PipeType == UsbdPipeTypeControl ? "UsbdPipeTypeControl" :
						//pInterface->Pipes[p].PipeType == UsbdPipeTypeIsochronous ? "UsbdPipeTypeIsochronous" :
						//pInterface->Pipes[p].PipeType == UsbdPipeTypeBulk ? "UsbdPipeTypeBulk" :
						//pInterface->Pipes[p].PipeType == UsbdPipeTypeInterrupt ? "UsbdPipeTypeInterrupt" : "!!! INVALID !!!");
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : PipeHandle        = 0x%p\n", i, p, pInterface->Pipes[p].PipeHandle);
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : MaxTransferSize   = 0x%x\n", i, p, pInterface->Pipes[p].MaximumTransferSize);
						//BufferPrintf(b,"  Interface[%d]: Pipes[%d] : PipeFlags         = 0x%x\n", i, p, pInterface->Pipes[p].PipeFlags);

						AddEndpointInfo(pInterface->Pipes[p].PipeHandle,
							pInterface->Pipes[p].EndpointAddress);
					}
				}

				pInterface = (PUSBD_INTERFACE_INFORMATION) (((UCHAR*)pInterface) + pInterface->Length);
			}
		}
		break;

	case URB_FUNCTION_SELECT_INTERFACE:
		{
			struct _URB_SELECT_INTERFACE  *pSelectInterface = (struct _URB_SELECT_INTERFACE *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SELECT_INTERFACE:\n");
			if(pSelectInterface->Hdr.Length < sizeof(struct _URB_SELECT_INTERFACE))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pSelectInterface->Hdr.Length, sizeof(struct _URB_SELECT_INTERFACE));
				return ;
			}
			//BufferPrintf(b,"  ConfigurationHandle     = 0x%x\n", pSelectInterface->ConfigurationHandle);

			PUSBD_INTERFACE_INFORMATION pInterface = &pSelectInterface->Interface;
			
			//BufferPrintf(b,"  Interface: Length            = %d\n", pInterface->Length);
			//BufferPrintf(b,"  Interface: InterfaceNumber   = %d\n", pInterface->InterfaceNumber);
			//BufferPrintf(b,"  Interface: AlternateSetting  = %d\n", pInterface->AlternateSetting);
			//BufferPrintf(b,"  Interface: Class             = 0x%x\n", pInterface->Class);
			//BufferPrintf(b,"  Interface: SubClass          = 0x%x\n", pInterface->SubClass);
			//BufferPrintf(b,"  Interface: Protocol          = 0x%x\n", pInterface->Protocol);
			//BufferPrintf(b,"  Interface: InterfaceHandle   = %p\n", pInterface->InterfaceHandle);
			//BufferPrintf(b,"  Interface: NumberOfPipes     = %d\n", pInterface->NumberOfPipes);
			if(bReturnedFromHCD)
			{
				ULONG uNumPipes = pInterface->NumberOfPipes;
				if(uNumPipes > 0x1f)
				{
					//BufferPrintf(b,"XXXXXX ERROR: uNumPipes is too large (%d), resetting to 1\n", uNumPipes);
					uNumPipes = 1;
				}
				for(ULONG p = 0; p< uNumPipes; p++)
				{
					//BufferPrintf(b,"  Interface: Pipes[%d] : MaximumPacketSize = 0x%x\n", p, pInterface->Pipes[p].MaximumPacketSize);
					//BufferPrintf(b,"  Interface: Pipes[%d] : EndpointAddress   = 0x%x\n", p, pInterface->Pipes[p].EndpointAddress);
					//BufferPrintf(b,"  Interface: Pipes[%d] : Interval          = 0x%x\n", p, pInterface->Pipes[p].Interval);
					//BufferPrintf(b,"  Interface: Pipes[%d] : PipeType          = 0x%x (%s)\n", p, pInterface->Pipes[p].PipeType,
					//	pInterface->Pipes[p].PipeType == UsbdPipeTypeControl ? "UsbdPipeTypeControl" :
					//pInterface->Pipes[p].PipeType == UsbdPipeTypeIsochronous ? "UsbdPipeTypeIsochronous" :
					//pInterface->Pipes[p].PipeType == UsbdPipeTypeBulk ? "UsbdPipeTypeBulk" :
					//pInterface->Pipes[p].PipeType == UsbdPipeTypeInterrupt ? "UsbdPipeTypeInterrupt" : "!!! INVALID !!!");
					//BufferPrintf(b,"  Interface: Pipes[%d] : PipeHandle        = 0x%p\n", p, pInterface->Pipes[p].PipeHandle);
					//BufferPrintf(b,"  Interface: Pipes[%d] : MaxTransferSize   = 0x%x\n", p, pInterface->Pipes[p].MaximumTransferSize);
					//BufferPrintf(b,"  Interface: Pipes[%d] : PipeFlags         = 0x%x\n", p, pInterface->Pipes[p].PipeFlags);

					AddEndpointInfo(pInterface->Pipes[p].PipeHandle,
						pInterface->Pipes[p].EndpointAddress);
				}
			}
		}
		break;

	case URB_FUNCTION_ABORT_PIPE: // tested [22/11/2001]
		{
			struct _URB_PIPE_REQUEST   *pAbortPipe = (struct _URB_PIPE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_ABORT_PIPE:\n");
			if(pAbortPipe->Hdr.Length < sizeof(struct _URB_PIPE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pAbortPipe->Hdr.Length, sizeof(struct _URB_PIPE_REQUEST));
				return ;
			}

			if(!bReturnedFromHCD)
				DumpPipeHandle(b,"  PipeHandle",pAbortPipe->PipeHandle);
		}
		break;

	case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL: // untested
		{
			struct _URB_FRAME_LENGTH_CONTROL *pFrameLengthControl = (struct _URB_FRAME_LENGTH_CONTROL *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:\n");
			if(pFrameLengthControl->Hdr.Length < sizeof(struct _URB_FRAME_LENGTH_CONTROL))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFrameLengthControl->Hdr.Length, sizeof(struct _URB_FRAME_LENGTH_CONTROL));
				return ;
			}

			//BufferPrintf(b,"  (no parameters)\n");
		}
		break;

	case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL: // untested
		{
			struct _URB_FRAME_LENGTH_CONTROL *pFrameLengthControl = (struct _URB_FRAME_LENGTH_CONTROL *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:\n");
			if(pFrameLengthControl->Hdr.Length < sizeof(struct _URB_FRAME_LENGTH_CONTROL))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFrameLengthControl->Hdr.Length, sizeof(struct _URB_FRAME_LENGTH_CONTROL));
				return ;
			}

			//BufferPrintf(b,"  (no parameters)\n");
		}
		break;

	case URB_FUNCTION_GET_FRAME_LENGTH: // untested
		{
			struct _URB_GET_FRAME_LENGTH   *pGetFrameLength = (struct _URB_GET_FRAME_LENGTH *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_FRAME_LENGTH:\n");
			if(pGetFrameLength->Hdr.Length < sizeof(struct _URB_GET_FRAME_LENGTH))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pGetFrameLength->Hdr.Length, sizeof(struct _URB_GET_FRAME_LENGTH));
				return ;
			}

			if(bReturnedFromHCD)
			{
				//BufferPrintf(b,"  FrameLength = %x\n", pGetFrameLength->FrameLength);
				//BufferPrintf(b,"  FrameNumber = %x\n", pGetFrameLength->FrameNumber);
			}
		}
		break;

	case URB_FUNCTION_SET_FRAME_LENGTH: // untested
		{
			struct _URB_SET_FRAME_LENGTH   *pSetFrameLength = (struct _URB_SET_FRAME_LENGTH *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_FRAME_LENGTH:\n");
			if(pSetFrameLength->Hdr.Length < sizeof(struct _URB_SET_FRAME_LENGTH))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pSetFrameLength->Hdr.Length, sizeof(struct _URB_SET_FRAME_LENGTH));
				return ;
			}

			//if(!bReturnedFromHCD)
				//BufferPrintf(b,"  FrameLengthDelta = %x\n", pSetFrameLength->FrameLengthDelta);
		}
		break;

	case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER: // untested
		{
			struct _URB_GET_CURRENT_FRAME_NUMBER   *pGetCurrentFrameNumber = (struct _URB_GET_CURRENT_FRAME_NUMBER *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:\n");
			if(pGetCurrentFrameNumber->Hdr.Length < sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pGetCurrentFrameNumber->Hdr.Length, sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER));
				return ;
			}

			//if(bReturnedFromHCD)
				//BufferPrintf(b,"  FrameNumber = %x\n", pGetCurrentFrameNumber->FrameNumber);
		}
		break;

	case URB_FUNCTION_CONTROL_TRANSFER: // tested [22/11/2001]
		{
			struct _URB_CONTROL_TRANSFER   *pControlTransfer = (struct _URB_CONTROL_TRANSFER *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CONTROL_TRANSFER:\n");
			if(pControlTransfer->Hdr.Length < sizeof(struct _URB_CONTROL_TRANSFER))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pControlTransfer->Hdr.Length, sizeof(struct _URB_CONTROL_TRANSFER));
				return ;
			}

			BOOLEAN bReadFromDevice = (BOOLEAN)(pControlTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle(b,"  PipeHandle          ",pControlTransfer->PipeHandle);
			//BufferPrintf(b,"  TransferFlags        = %x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pControlTransfer->TransferFlags,
			//	bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
			//	pControlTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~");
			DumpTransferBuffer(b,(PUCHAR)pControlTransfer->TransferBuffer,
				pControlTransfer->TransferBufferMDL,
				pControlTransfer->TransferBufferLength, TRUE);
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer(b,(PUCHAR)pControlTransfer->TransferBuffer,
					pControlTransfer->TransferBufferMDL, pControlTransfer->TransferBufferLength, FALSE);
			}

			//BufferPrintf(b,"  UrbLink              = %x\n", pControlTransfer->UrbLink);
			//BufferPrintf(b,"  SetupPacket          =\n");
			DumpBuffer(b,pControlTransfer->SetupPacket,
				sizeof(pControlTransfer->SetupPacket));

			if(pControlTransfer->UrbLink)
			{
				//BufferPrintf(b,"---> Linked URB:\n");
				DumpURB(b,pControlTransfer->UrbLink, bReturnedFromHCD);
				//BufferPrintf(b,"---< Linked URB\n");
			}
		}
		break;

	case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER: // tested [22/11/2001]  
		{
			struct _URB_BULK_OR_INTERRUPT_TRANSFER *pBulkOrInterruptTransfer = (struct _URB_BULK_OR_INTERRUPT_TRANSFER *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:\n");
			if(pBulkOrInterruptTransfer->Hdr.Length < sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER ))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pBulkOrInterruptTransfer->Hdr.Length,
				//	sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
				return ;
			}

			BOOLEAN bReadFromDevice = (BOOLEAN)(pBulkOrInterruptTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			
			DumpPipeHandle(b,"  PipeHandle          ",pBulkOrInterruptTransfer->PipeHandle);

			//BufferPrintf(b,"  TransferFlags        = %x (%s, %sUSBD_SHORT_TRANSFER_OK)\n", pBulkOrInterruptTransfer->TransferFlags,
			//	bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
			//	pBulkOrInterruptTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~");
			
			//j here
			DumpTransferBuffer(b,(PUCHAR)pBulkOrInterruptTransfer->TransferBuffer, pBulkOrInterruptTransfer->TransferBufferMDL, pBulkOrInterruptTransfer->TransferBufferLength, TRUE);
			
			if(((!bReadFromDevice) && (!bReturnedFromHCD)) || (bReadFromDevice && bReturnedFromHCD))
			{
				DumpTransferBuffer(b,(PUCHAR)pBulkOrInterruptTransfer->TransferBuffer, pBulkOrInterruptTransfer->TransferBufferMDL, pBulkOrInterruptTransfer->TransferBufferLength, FALSE);
			}

			//BufferPrintf(b,"  UrbLink              = %x\n", pBulkOrInterruptTransfer->UrbLink);
			if(pBulkOrInterruptTransfer->UrbLink)
			{
				//BufferPrintf(b,"---> Linked URB:\n");
				DumpURB(b,pBulkOrInterruptTransfer->UrbLink, bReturnedFromHCD);
				//BufferPrintf(b,"---< Linked URB\n");
			}
		}
		break;

	case URB_FUNCTION_ISOCH_TRANSFER: // tested [22/11/2001]
		{
			struct _URB_ISOCH_TRANSFER *pIsochTransfer = (struct _URB_ISOCH_TRANSFER *) pUrb;
			BOOLEAN dumpBuffer = FALSE;

			//BufferPrintf(b,"-- URB_FUNCTION_ISOCH_TRANSFER:\n");
			if(pIsochTransfer->Hdr.Length < sizeof(struct _URB_ISOCH_TRANSFER ))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pIsochTransfer->Hdr.Length, sizeof(struct _URB_ISOCH_TRANSFER));
				return ;
			}

			BOOLEAN bReadFromDevice = (BOOLEAN)(pIsochTransfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
			DumpPipeHandle(b,"  PipeHandle          ",pIsochTransfer->PipeHandle);
			//BufferPrintf(b,"  TransferFlags        = %x (%s, %sUSBD_SHORT_TRANSFER_OK%s\n", pIsochTransfer->TransferFlags,
			//	bReadFromDevice ? "USBD_TRANSFER_DIRECTION_IN" : "USBD_TRANSFER_DIRECTION_OUT",
			//	pIsochTransfer->TransferFlags & USBD_SHORT_TRANSFER_OK ? "":"~",
			//	pIsochTransfer->TransferFlags & USBD_START_ISO_TRANSFER_ASAP ? ", USBD_START_ISO_TRANSFER_ASAP" : "");

			DumpTransferBuffer(b,(PUCHAR)pIsochTransfer->TransferBuffer, pIsochTransfer->TransferBufferMDL, pIsochTransfer->TransferBufferLength, TRUE);
			if( (!bReadFromDevice && !bReturnedFromHCD)
				|| (bReadFromDevice && bReturnedFromHCD) )
			{
				dumpBuffer = TRUE;
//				DumpTransferBuffer((PUCHAR)pIsochTransfer->TransferBuffer, pIsochTransfer->TransferBufferMDL, pIsochTransfer->TransferBufferLength, FALSE);
			}

			//BufferPrintf(b,"  StartFrame           = %x\n", pIsochTransfer->StartFrame);
			//BufferPrintf(b,"  NumberOfPackets      = %x\n", pIsochTransfer->NumberOfPackets);
			if(bReturnedFromHCD)
				//BufferPrintf(b,"  ErrorCount           = %x\n", pIsochTransfer->ErrorCount);

			for(ULONG p=0; p < pIsochTransfer->NumberOfPackets; p++)
			{
				//BufferPrintf(b,"  IsoPacket[%d].Offset = %d\n",p, pIsochTransfer->IsoPacket[p].Offset);
				//BufferPrintf(b,"  IsoPacket[%d].Length = %d\n",p, pIsochTransfer->IsoPacket[p].Length);
				// possible value for Status are described in <usbdi.h>
				// search for USBD_STATUS_SUCCESS (0).
				if(bReturnedFromHCD)
					//BufferPrintf(b,"  IsoPacket[%d].Status = %x\n",p, pIsochTransfer->IsoPacket[p].Status);
				if (dumpBuffer)
					DumpTransferBuffer(b,(PUCHAR)pIsochTransfer->TransferBuffer,
						pIsochTransfer->TransferBufferMDL,
						pIsochTransfer->IsoPacket[p].Length, FALSE,
						pIsochTransfer->IsoPacket[p].Offset);
			}

			//BufferPrintf(b,"  UrbLink              = %x\n", pIsochTransfer->UrbLink);
			if(pIsochTransfer->UrbLink)
			{
				//BufferPrintf(b,"---> Linked URB:\n");
				DumpURB(b,pIsochTransfer->UrbLink, bReturnedFromHCD);
				//BufferPrintf(b,"---< Linked URB\n");
			}
		}
		break;

	case URB_FUNCTION_RESET_PIPE:
		{
			struct _URB_PIPE_REQUEST   *pResetPipe = (struct _URB_PIPE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_RESET_PIPE:\n");
			if(pResetPipe->Hdr.Length < sizeof(struct _URB_PIPE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pResetPipe->Hdr.Length, sizeof(struct _URB_PIPE_REQUEST));
				return ;
			}

			if(!bReturnedFromHCD)
				DumpPipeHandle(b,"  PipeHandle",pResetPipe->PipeHandle);
		}
		break;

	case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromDevice = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:\n");
			if(pGetDescriptorFromDevice->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromDevice->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
				return ;
			}

			DumpDescriptorRequest(b,pGetDescriptorFromDevice, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromEndpoint = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:\n");
			if(pGetDescriptorFromEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
				return ;
			}

			DumpDescriptorRequest(b,pGetDescriptorFromEndpoint, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pGetDescriptorFromInterface = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:\n");
			if(pGetDescriptorFromInterface->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetDescriptorFromInterface->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
				return ;
			}

			DumpDescriptorRequest(b,pGetDescriptorFromInterface, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToDevice = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:\n");
			if(pSetDescriptorToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
				return ;
			}

			DumpDescriptorRequest(b,pSetDescriptorToDevice, FALSE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToEndpoint = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:\n");
			if(pSetDescriptorToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
				return ;
			}

			DumpDescriptorRequest(b,pSetDescriptorToEndpoint, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
		{
			struct _URB_CONTROL_DESCRIPTOR_REQUEST   *pSetDescriptorToInterface = (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:\n");
			if(pSetDescriptorToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetDescriptorToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));				return ;
			}

			DumpDescriptorRequest(b,pSetDescriptorToInterface, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToDevice = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_FEATURE_TO_DEVICE:\n");
			if(pSetFeatureToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pSetFeatureToDevice, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToInterface = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_FEATURE_TO_INTERFACE:\n");
			if(pSetFeatureToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pSetFeatureToInterface, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToEndpoint = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:\n");
			if(pSetFeatureToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pSetFeatureToEndpoint, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_SET_FEATURE_TO_OTHER:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pSetFeatureToOther = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_SET_FEATURE_TO_OTHER:\n");
			if(pSetFeatureToOther->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pSetFeatureToOther->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pSetFeatureToOther, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToDevice = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:\n");
			if(pClearFeatureToDevice->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToDevice->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pClearFeatureToDevice, TRUE, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToInterface = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:\n");
			if(pClearFeatureToInterface->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToInterface->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pClearFeatureToInterface, TRUE, bReturnedFromHCD);

		}
		break;

	case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToEndpoint = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:\n");
			if(pClearFeatureToEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pClearFeatureToEndpoint, TRUE, bReturnedFromHCD);

		}
		break;

	case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
		{
			struct _URB_CONTROL_FEATURE_REQUEST   *pClearFeatureToOther = (struct _URB_CONTROL_FEATURE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:\n");
			if(pClearFeatureToOther->Hdr.Length < sizeof(struct _URB_CONTROL_FEATURE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pClearFeatureToOther->Hdr.Length, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));
				return ;
			}

			DumpFeatureRequest(b,pClearFeatureToOther, TRUE, bReturnedFromHCD);

		}
		break;

	case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromDevice = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_STATUS_FROM_DEVICE:\n");
			if(pGetStatusFromDevice->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromDevice->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST));
				return ;
			}

			DumpGetStatusRequest(b,pGetStatusFromDevice, bReturnedFromHCD);

		}

	case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
		return ;
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromInterface = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_STATUS_FROM_INTERFACE:\n");
			if(pGetStatusFromInterface->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromInterface->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST));
				return ;
			}

			DumpGetStatusRequest(b,pGetStatusFromInterface, bReturnedFromHCD);

		}

	case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromEndpoint = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:\n");
			if(pGetStatusFromEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromEndpoint->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST));
				return ;
			}

			DumpGetStatusRequest(b,pGetStatusFromEndpoint, bReturnedFromHCD);

		}
		break;

	case URB_FUNCTION_GET_STATUS_FROM_OTHER:
		{
			struct _URB_CONTROL_GET_STATUS_REQUEST *pGetStatusFromOther = (struct _URB_CONTROL_GET_STATUS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_STATUS_FROM_OTHER:\n");
			if(pGetStatusFromOther->Hdr.Length < sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pGetStatusFromOther->Hdr.Length, sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST));
				return ;
			}

			DumpGetStatusRequest(b,pGetStatusFromOther, bReturnedFromHCD);

		}
		break;

	case URB_FUNCTION_VENDOR_DEVICE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorDevice = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_VENDOR_DEVICE:\n");
			if(pFunctionVendorDevice->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorDevice->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionVendorDevice, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_VENDOR_INTERFACE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorInterface = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_VENDOR_INTERFACE:\n");
			if(pFunctionVendorInterface->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionVendorInterface->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionVendorInterface, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_VENDOR_ENDPOINT:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorEndpoint = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_VENDOR_ENDPOINT:\n");
			if(pFunctionVendorEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFunctionVendorEndpoint->Hdr.Length,
				//	sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionVendorEndpoint, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_VENDOR_OTHER:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionVendorOther = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_VENDOR_OTHER:\n");
			if(pFunctionVendorOther->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFunctionVendorOther->Hdr.Length,
				//	sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionVendorOther, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_CLASS_DEVICE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassDevice = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLASS_DEVICE:\n");
			if(pFunctionClassDevice->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFunctionClassDevice->Hdr.Length,
				//	sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionClassDevice, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_CLASS_INTERFACE:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassInterface = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLASS_INTERFACE:\n");
			if(pFunctionClassInterface->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n", pFunctionClassInterface->Hdr.Length, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

			DumpVendorOrClassRequest(b,pFunctionClassInterface, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_CLASS_ENDPOINT:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassEndpoint = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLASS_ENDPOINT:\n");
			if(pFunctionClassEndpoint->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFunctionClassEndpoint->Hdr.Length,
				//	sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionClassEndpoint, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_CLASS_OTHER:
		{
			struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *pFunctionClassOther = (struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_CLASS_OTHER:\n");
			if(pFunctionClassOther->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pFunctionClassOther->Hdr.Length,
				//	sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
				return ;
			}

			DumpVendorOrClassRequest(b,pFunctionClassOther, bReturnedFromHCD);
		}
		break;

	case URB_FUNCTION_GET_CONFIGURATION:
		{
			struct _URB_CONTROL_GET_CONFIGURATION_REQUEST *pGetConfiguration = (struct _URB_CONTROL_GET_CONFIGURATION_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_CONFIGURATION:\n");
			if(pGetConfiguration->Hdr.Length < sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pGetConfiguration->Hdr.Length,
				//	sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST));
				return ;
			}

			DumpTransferBuffer(b,(PUCHAR)pGetConfiguration->TransferBuffer, pGetConfiguration->TransferBufferMDL, pGetConfiguration->TransferBufferLength, TRUE);
			if(pGetConfiguration->TransferBufferLength != 1)
				//BufferPrintf(b,"  *** error - TransferBufferLength should be 1!\n");

			if(bReturnedFromHCD)
			{
				DumpTransferBuffer(b,(PUCHAR)pGetConfiguration->TransferBuffer, pGetConfiguration->TransferBufferMDL, pGetConfiguration->TransferBufferLength, FALSE);
			}

			//BufferPrintf(b,"  UrbLink              = %x\n", pGetConfiguration->UrbLink);
			if(pGetConfiguration->UrbLink)
			{
				//BufferPrintf(b,"---> Linked URB:\n");
				DumpURB(b,pGetConfiguration->UrbLink, bReturnedFromHCD);
				//BufferPrintf(b,"---< Linked URB\n");
			}
		}
		break;

	case URB_FUNCTION_GET_INTERFACE:
		{
			struct _URB_CONTROL_GET_INTERFACE_REQUEST *pGetInterface = (struct _URB_CONTROL_GET_INTERFACE_REQUEST *) pUrb;

			//BufferPrintf(b,"-- URB_FUNCTION_GET_INTERFACE:\n");
			if(pGetInterface->Hdr.Length < sizeof(struct _URB_CONTROL_GET_INTERFACE_REQUEST))
			{
				//BufferPrintf(b,"!!! Hdr.Length is wrong! (is: %d, should be at least: %d)\n",
				//	pGetInterface->Hdr.Length, sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST));
				return ;
			}

			DumpTransferBuffer(b,(PUCHAR)pGetInterface->TransferBuffer, pGetInterface->TransferBufferMDL, pGetInterface->TransferBufferLength, TRUE);
			if(pGetInterface->TransferBufferLength != 1)
				//BufferPrintf(b,"  *** error - TransferBufferLength should be 1!\n");

			if(bReturnedFromHCD)
			{
				DumpTransferBuffer(b,(PUCHAR)pGetInterface->TransferBuffer, pGetInterface->TransferBufferMDL, pGetInterface->TransferBufferLength, FALSE);
			}

			//BufferPrintf(b,"  Interface            = %x\n", pGetInterface->UrbLink);
			//BufferPrintf(b,"  UrbLink              = %x\n", pGetInterface->UrbLink);
			if(pGetInterface->UrbLink)
			{
				//BufferPrintf(b,"---> Linked URB:\n");
				DumpURB(b,pGetInterface->UrbLink, bReturnedFromHCD);
				//BufferPrintf(b,"---< Linked URB\n");
			}
		}
		break;

	default:
		//BufferPrintf(b,"******* non printable URB with function code 0x%x ********\n", wFunction);
		break;
	}	// end of mega switch
}

NTSTATUS MyInternalIOCTLCompletion(IN PDEVICE_OBJECT fido, IN PIRP Irp, IN PVOID inContext)
{
	struct Buffer b;

//	LogPrintf("UsbSnoop - MyInternalIOCTLCompletion(%p) : fido=%p, Irp=%p, Context=%p, IRQL=%d\n",
//		MyInternalIOCTLCompletion,fido,Irp,inContext,KeGetCurrentIrql());

//	DumpIrp(Irp);

	PCONTEXT Context = (PCONTEXT)inContext;
//	DumpContext(Context);

//	if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
//		KeInsertQueueDpc (&gDPC,NULL,NULL);

	// restoring information.

	Context->Stack->CompletionRoutine = Context->CompletionRoutine;
	Context->Stack->Context           = Context->Context;
	Context->Stack->Control           = Context->Control;

	// dumping URB 

	BufferInit(&b);
	//BufferPrintf(&b," <<<  URB %d coming back  <<< \n",Context->uSequenceNumber);
	DumpURB(&b,Context->pUrb, TRUE);

	LogBuffer(&b);
	BufferDone(&b);

	// saving some field before freeing the structure
	PVOID OldContext = Context->Context;
	PIO_COMPLETION_ROUTINE OldCompletionRoutine = Context->CompletionRoutine;

	// freeing the allocated structure
	ExFreePool(Context);

	// calling the old CompletionRoutine, if there was one

	if (OldCompletionRoutine != NULL)
		return OldCompletionRoutine(fido,Irp,OldContext);

	return STATUS_SUCCESS;
}

NTSTATUS MyDispatchInternalIOCTL(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
	//LogPrintf("UsbSnoop - MyDispatchInternalIOCTL(%p) : fdo=%p, Irp=%p, IRQL=%d\n",MyDispatchInternalIOCTL,fdo,Irp,KeGetCurrentIrql());
/*
	if (KeGetCurrentIrql() == PASSIVE_LEVEL)
		DbgPrint("MyDispatchInternalIOCTL - Priority=%d\n",
			KeQueryPriorityThread(KeGetCurrentThread()));
*/
//	DumpDeviceObject(fdo);
//	DumpIrp(Irp);

//	if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
//		KeInsertQueueDpc (&gDPC,NULL,NULL);

	// we want to recover OriginalDriverObject which is stored in fido,
	// so we need to recover fido first, by the AttachedDevice field from FDO.

	PDEVICE_OBJECT fido = fdo->AttachedDevice;
//	LogPrintf("  fido = %p\n",fido));

	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
//	LogPrintf("  OriginalDriverObject = %p\n",pdx->OriginalDriverObject));

	// try to print the URB 

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG dwControlCode = stack->Parameters.DeviceIoControl.IoControlCode;
//	LogPrintf("  dwControlCode=%d\n",dwControlCode));
	if (dwControlCode == IOCTL_INTERNAL_USB_SUBMIT_URB)
	{
		struct Buffer b;
		ULONG uSequenceNumber = InterlockedIncrement((PLONG)&pdx->uSequenceNumber);

		BufferInit(&b);

		//BufferPrintf(&b," >>>  URB %d going down  >>> \n", uSequenceNumber);

		// we cannot call ZwWriteFile() cause it must be running at
		// IRQL_PASSIVE_LEVEL (0) and most of the time, MyDispatchInternalIOCTL
		// is running at IRQL_DISPATCH_LEVEL (2).
		// LogPrintf(" KeGetCurrentIrql() = %d\n",KeGetCurrentIrql()));

		PURB pUrb = (PURB) stack->Parameters.Others.Argument1;
		DumpURB(&b,pUrb,FALSE);

		// inspired from the macro code of IoSetCompletionRoutine
		// it just makes a big BSOD

		// ok. in fact, it worked, but that particular case,
		// the first parameter of the IoCompletionRoutine is NULL instead of being fido !!!

		// normally, there should be a call to IoCopyCurrentIrpStackLocationToNext()
		// which might not be there. So, we are surely replacing other callbacks.

		// first, we saved every information we'll modify later

		/*
			Windows 2000 DDK : Note that the context area cannot be pageable
			because the IoCompletion routine can be called at IRQL
			DISPATCH_LEVEL
		*/

		PCONTEXT Context = (PCONTEXT)ExAllocatePool(NonPagedPool,sizeof(CONTEXT));
		if (Context != NULL)
		{
			Context->CompletionRoutine = stack->CompletionRoutine;
			Context->Context           = stack->Context;
			Context->Control           = stack->Control;
			Context->pUrb              = pUrb;
			Context->uSequenceNumber   = uSequenceNumber;
			Context->Stack             = stack;

//			LogPrintf("  Replacing %p/%p/%p by ",
//				stack->CompletionRoutine,stack->Context,stack->Control));
			stack->CompletionRoutine = MyInternalIOCTLCompletion;
			stack->Context = Context;
			stack->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

//			LogPrintf("%p/%p/%p\n",stack->CompletionRoutine,stack->Context,stack->Control));
		}
		else
		//	LogPrintf("  ExAllocatePool failed! Can't redirect CompletionRoutine\n");

		LogBuffer(&b);
		BufferDone(&b);
	}

	return pdx->OriginalDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL](fdo,Irp);
}

/*
	DispatchPower - need a special code, since we have to call PoCallDriver()
	instead of IoCallDriver()
*/

NTSTATUS DispatchPower(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char* fcnname[] =
	{
		"IRP_MN_WAIT_WAKE",
		"IRP_MN_POWER_SEQUENCE",
		"IRP_MN_SET_POWER",
		"IRP_MN_QUERY_POWER",
	};
	
	if (fcn == IRP_MN_SET_POWER || fcn == IRP_MN_QUERY_POWER)
	{
		const char* sysstate[] =
		{
			"PowerSystemUnspecified",
			"PowerSystemWorking",
			"PowerSystemSleeping1",
			"PowerSystemSleeping2",
			"PowerSystemSleeping3",
			"PowerSystemHibernate",
			"PowerSystemShutdown",
			"PowerSystemMaximum",
		};
		
		const char* devstate[] =
		{
			"PowerDeviceUnspecified",
			"PowerDeviceD0",
			"PowerDeviceD1",
			"PowerDeviceD2",
			"PowerDeviceD3",
			"PowerDeviceMaximum",
		};
		
		ULONG context = stack->Parameters.Power.SystemContext;
		POWER_STATE_TYPE type = stack->Parameters.Power.Type;
		
		//LogPrintf("UsbSnoop - IRP_MJ_POWER (%s), SystemContext %x", fcnname[fcn], context);
		//if (type == SystemPowerState)
		//	LogPrintf(", SystemPowerState = %s\n", sysstate[stack->Parameters.Power.State.SystemState]);
		//else
		//	LogPrintf(", DevicePowerState = %s\n", devstate[stack->Parameters.Power.State.DeviceState]);
	}
	//else
	//	LogPrintf("UsbSnoop - IRP_MJ_POWER (%s)\n", fcnname[fcn]);
		
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	PoStartNextPowerIrp(Irp);	// must be done while we own the IRP
	NTSTATUS status;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = PoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}

///////////////////////////////////////////////////////////////////////////////

NTSTATUS DispatchPnp(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	const char * MinorFunctionName = GetIrpPnpMinorFunctionName(fcn);
/*	if (MinorFunctionName != NULL)
		LogPrintf("UsbSnoop - DispatchPNP(%p) : IRP_MJ_PNP (%s)\n",
			DispatchPnp,MinorFunctionName);
	else
		LogPrintf("UsbSnoop - DispatchPNP(%p) : IRP_MJ_PNP (0x%x)\n",
			DispatchPnp,fcn);
	*/
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	//JJ From KB 298504 to avaoid unsafe removal on 2000
	//The problem is the LAN driver do not support unsafe removal, the BT drivers seems ok, must disable LAN driver
	//if(fcn == IRP_MN_QUERY_CAPABILITIES &&  !IoIsWdmVersionAvailable(1, 0x20))
	//{
	//	stack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
	//}
	//end
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	//JJ
	//if(fcn == IRP_MN_QUERY_CAPABILITIES &&  !IoIsWdmVersionAvailable(1, 0x20))
	//{
	//	stack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
	//}


	//end
	if (fcn == IRP_MN_REMOVE_DEVICE)
	{
		IoReleaseRemoveLockAndWait(&pdx->RemoveLock, Irp);
		RemoveDevice(fido);
	}
	else
		IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	
	return status;
}

///////////////////////////////////////////////////////////////////////////////

NTSTATUS DispatchWmi(IN PDEVICE_OBJECT fido, IN PIRP Irp)
{							// DispatchWmi
#if DBG
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG fcn = stack->MinorFunction;
	
	static char* fcnname[] = {
		"IRP_MN_QUERY_ALL_DATA",
		"IRP_MN_QUERY_SINGLE_INSTANCE",
		"IRP_MN_CHANGE_SINGLE_INSTANCE",
		"IRP_MN_CHANGE_SINGLE_ITEM",
		"IRP_MN_ENABLE_EVENTS",
		"IRP_MN_DISABLE_EVENTS",
		"IRP_MN_ENABLE_COLLECTION",
		"IRP_MN_DISABLE_COLLECTION",
		"IRP_MN_REGINFO",
		"IRP_MN_EXECUTE_METHOD",
	};
	
	//LogPrintf("UsbSnoop - IRP_MJ_SYSTEM_CONTROL (%s)\n", fcnname[fcn]);
#endif // DBG
	
	NTSTATUS status;
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;
	status = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);
	if (!NT_SUCCESS(status))
		return CompleteRequest(Irp, status, 0);
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->LowerDeviceObject, Irp);
	IoReleaseRemoveLock(&pdx->RemoveLock, Irp);
	return status;
}
